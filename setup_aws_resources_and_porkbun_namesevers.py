# send off cloud formation template
import boto3
import datetime
import pprint
import re
import requests
import sys
import time

from argparse import ArgumentParser

cf_client = boto3.client('cloudformation')
r53_client = boto3.client('route53')

def parseCookieFile(cookiefile):
    """Parse a cookies.txt file and return a dictionary of key value pairs
    compatible with requests.
    
    """
    cookies = {}
    with open (cookiefile, 'r') as fp:
        for line in fp:
            if not re.match(r'^(\#|\n)', line):
                lineFields = line.strip().split('\t')
                cookies[lineFields[5]] = lineFields[6]
    return cookies

def create_stack(template_path):
    """Creates a CFT stack using the template at the path specified by the parameter {template_path}.
    The stack will have a name based on its creation time (local to the machine this script is ran on),
    similar to "WebsiteStack-2021-10-20-14-58-20".

    """
    STACK_NAME = f"WebsiteStack-{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}"
    stack_id = cf_client.create_stack(
        StackName=STACK_NAME,
        TemplateBody=open(template_path, "r").read(),
        Tags=[
            {
                'Key': 'Created-By-This-Stack',
                'Value': STACK_NAME
            }
        ]
    )["StackId"]
    print(f"Successfully created CFT stack with stack_id: {stack_id}")
    return stack_id

def get_name_servers(stack_id):
    """Polls the CFT stack every 10 seconds to check if the HostedZone is up.
    Once it is up, this function returns the AWS nameservers (associated with the HostedZone) formatted as
    a single string, where different nameservers are separated by a newline.
    
    """
    hosted_zone_is_not_up = True
    while hosted_zone_is_not_up:
        print("hosted zone is not up")
        stack_resources = cf_client.describe_stack_resources(StackName=stack_id)["StackResources"]
        for resource in stack_resources:
            if resource["ResourceType"] == "AWS::Route53::HostedZone" and resource["ResourceStatus"] == "CREATE_COMPLETE":
                # get NS from hosted zone record
                print("hosted zone is up")
                hosted_zone_is_not_up = False
                hosted_zone_id = resource['PhysicalResourceId']
                print(f"hosted_zone_id: {hosted_zone_id}")
                all_records = r53_client.list_resource_record_sets(
                    HostedZoneId=hosted_zone_id
                )["ResourceRecordSets"]
                NS_record = [record for record in all_records if record["Type"] == "NS"][0]
                values = NS_record["ResourceRecords"]
                all_nameservers = "\n".join([x["Value"] for x in values])
                print(f"Successfully got AWS nameservers from hosted zone:\n{all_nameservers}")
                return all_nameservers
            elif (resource["ResourceType"] == "AWS::CloudFormation::Stack" or resource["ResourceType"] == "AWS::Route53::HostedZone") and resource["ResourceStatus"] == "CREATE_FAILED":
                raise Exception("Stack Failed")
        time.sleep(10.0)

def update_name_servers_in_porkbun(nameservers, cookies_path):
    """Updates the Authoritative Nameservers in Porkbun with the given {nameservers}.
    {nameservers} must be formatted as a single string, where different nameservers are separated by a newline.
    {cookies_path} is the path to a cookies file generated by the "cookies.txt" extension for Google Chrome. You will need to manually export that file after logging into porkbun.com
    
    NOTE: This is extremely hacky since this is an undocumented endpoint. According to a customer service email:

    "Hi Brandon,

    We don't have any API functionality to change nameservers within Porkbun at this time. It is something we have discussed, however, and have a feature request for.


    Best,
    Dylan
    Support Engineer"

    So once this endpoint is official, it'll stop being so bad with manual passing of cookies...

    Returns the response from requests.post if successful, raises an Exception if not successful

    """
    cookies = parseCookieFile(cookies_path)
    headers = {
        'authority': 'porkbun.com',
        'sec-ch-ua': '"Chromium";v="94", "Google Chrome";v="94", ";Not A Brand";v="99"',
        'accept': 'application/json, text/javascript, */*; q=0.01',
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'x-requested-with': 'XMLHttpRequest',
        'sec-ch-ua-mobile': '?0',
        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36',
        'sec-ch-ua-platform': '"Windows"',
        'origin': 'https://porkbun.com',
        'sec-fetch-site': 'same-origin',
        'sec-fetch-mode': 'cors',
        'sec-fetch-dest': 'empty',
        'referer': 'https://porkbun.com/',
        'accept-language': 'en-US,en;q=0.9',
    }
    data = {
    'domain': 'brandonthe.gay',
    'nameservers': nameservers,
    'bulkDomains': '',
    'isajax': 'true',
    'csrf_pb': cookies['csrf_pb']
    }
    response = requests.post('https://porkbun.com/api/domains/updateDomainNameservers', headers=headers, data=data, cookies=cookies)
    if response.status_code == 200:
        print("Successfully updated porkbun nameservers")
    else:
        raise Exception(f"Response from porkbun was not 200 Okay:\n{response.status_code}\n{response.text}")
    return response
    
def main(args):
    """This script is used to create the AWS CFT stack for the website's infrastructure while also updating porkbun's Authoritative Nameservers to use AWS's.

    """
    parser = ArgumentParser()
    parser.add_argument('--cookies-file-path', default="porkbun.com_cookies.txt", help='path to the cookies file from cookies.txt for porkbun.com')
    args = parser.parse_args(args)

    stack_id = create_stack("cloudformation.yml")
    nameservers = get_name_servers(stack_id)
    nameservers = "ns-1484.awsdns-57.org\nns-1966.awsdns-53.co.uk\nns-436.awsdns-54.com\nns-599.awsdns-10.net"
    update_name_servers_in_porkbun(nameservers, args.cookies_file_path)

if __name__ == '__main__':
    main(sys.argv[1:])